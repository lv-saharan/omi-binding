{
  "version": 3,
  "sources": ["../node_modules/omi/src/util.js", "../node_modules/omi/src/extend.js", "../src/index.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n;(function() {\n  if (\n    // No Reflect, no classes, no need for shim because native custom elements\n    // require ES2015 classes or Reflect.\n    window.Reflect === undefined ||\n    window.customElements === undefined ||\n    // The webcomponentsjs custom elements polyfill doesn't require\n    // ES2015-compatible construction (`super()` or `Reflect.construct`).\n    window.customElements.hasOwnProperty('polyfillWrapFlushCallback')\n  ) {\n    return\n  }\n  const BuiltInHTMLElement = HTMLElement\n  window.HTMLElement = function HTMLElement() {\n    return Reflect.construct(BuiltInHTMLElement, [], this.constructor)\n  }\n  HTMLElement.prototype = BuiltInHTMLElement.prototype\n  HTMLElement.prototype.constructor = HTMLElement\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement)\n})()\n\nexport function cssToDom(css) {\n  const node = document.createElement('style')\n  node.textContent = css\n  return node\n}\n\nexport function camelCase(str) {\n  return str.replace(/-(\\w)/g, ($, $1) => {\n    return $1.toUpperCase()\n  })\n}\n\nexport function Fragment(props) {\n  return props.children\n}\n\nexport function extend(obj, props) {\n  for (let i in props) obj[i] = props[i]\n  return obj\n}\n\n/** Invoke or update a ref, depending on whether it is a function or object ref.\n *  @param {object|function} [ref=null]\n *  @param {any} [value]\n */\nexport function applyRef(ref, value) {\n  if (ref != null) {\n    if (typeof ref == 'function') ref(value)\n    else ref.current = value\n  }\n}\n\n/**\n * Call a function asynchronously, as soon as possible. Makes\n * use of HTML Promise to schedule the callback if available,\n * otherwise falling back to `setTimeout` (mainly for IE<11).\n * @type {(callback: function) => void}\n */\nexport const defer =\n  typeof Promise == 'function'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : setTimeout\n\nexport function isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]'\n}\n\nexport function pathToArr(path) {\n  if (typeof path !== 'string' || !path) return []\n  // return path.split(/\\.|\\[|\\]/).filter(name => !!name)\n  return path\n    .replace(/]/g, '')\n    .replace(/\\[/g, '.')\n    .split('.')\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport function hyphenate(str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport function capitalize(name) {\n  return name\n    .replace(/\\-(\\w)/g, function(all, letter) {\n      return letter.toUpperCase()\n    })\n    .replace(/^\\S/, s => s.toUpperCase())\n}\n\nexport function getValByPath(path, current) {\n  const arr = pathToArr(path)\n  arr.forEach(prop => {\n    current = current[prop]\n  })\n  return current\n}\n\nexport function removeItem(item, arr) {\n  if (!arr) return\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (arr[i] === item) {\n      arr.splice(i, 1)\n      break\n    }\n  }\n}\n", "import { pathToArr } from './util'\n\nexport const extension = {}\n\nexport function extend(name, handler) {\n  extension['o-' + name] = handler\n}\n\nexport function set(origin, path, value) {\n  const arr = pathToArr(path)\n  let current = origin\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (i === len - 1) {\n      current[arr[i]] = value\n    } else {\n      current = current[arr[i]]\n    }\n  }\n}\n\nexport function get(origin, path) {\n  const arr = pathToArr(path)\n  let current = origin\n  for (let i = 0, len = arr.length; i < len; i++) {\n    current = current[arr[i]]\n  }\n\n  return current\n}\n\nfunction eventProxy(e) {\n  return this._listeners[e.type](e)\n}\n\nexport function bind(el, type, handler) {\n  el._listeners = el._listeners || {}\n  el._listeners[type] = handler\n  el.addEventListener(type, eventProxy)\n}\n\nexport function unbind(el, type) {\n  el.removeEventListener(type, eventProxy)\n}\n", "import { extend, get, set } from \"omi/src/extend\";\r\n\r\nfunction eventProxy(e) {\r\n  return this._bindingListeners[e.type](e);\r\n}\r\n\r\nfunction bind(el, type, handler) {\r\n  el._bindingListeners = el._bindingListeners || {};\r\n  el._bindingListeners[type] = handler;\r\n  el.addEventListener(type, eventProxy);\r\n}\r\n\r\nfunction unbind(el, type) {\r\n  el.removeEventListener(type, eventProxy);\r\n}\r\n\r\nconst BINDING_HANDLERS = [];\r\n\r\nconst addBindingHandler = (handler) => {\r\n  BINDING_HANDLERS.push(handler);\r\n};\r\nconst isChangeOnUpdate = (el) => {\r\n  if (el.hasAttribute(\"change-on-update\")) {\r\n    let val = el.getAttribute(\"change-on-update\");\r\n    return val === true || val === \"1\" || val === \"true\";\r\n  }\r\n  return true;\r\n};\r\nconst updateSelect = (el, path, scope) => {\r\n  let val = get(scope, path);\r\n  if (val instanceof Array && el.multiple) {\r\n    Array.from(el.options).forEach((option) => {\r\n      if (val.some((v) => v == option.value)) {\r\n        option.selected = true;\r\n      } else {\r\n        option.selected = false;\r\n      }\r\n    });\r\n\r\n    return;\r\n  }\r\n  if (val === false || val === null || val === undefined) {\r\n    val = \"\";\r\n  }\r\n  el.value = val;\r\n};\r\n/**\r\n * add select binding handler\r\n */\r\naddBindingHandler((el, path, scope) => {\r\n  if (el.nodeName === \"SELECT\") {\r\n    unbind(el, \"change\");\r\n    bind(el, \"change\", () => {\r\n      const value = get(scope, path);\r\n      if (value instanceof Array) {\r\n        value.splice(\r\n          0,\r\n          value.length,\r\n          ...Array.from(el.selectedOptions)\r\n            .filter((option) => option.value != \"\")\r\n            .map((option) => option.value)\r\n        );\r\n      } else {\r\n        set(scope, path, el.value);\r\n      }\r\n    });\r\n    return updateSelect;\r\n  }\r\n});\r\n\r\nconst updateRadio = (el, path, scope) => {\r\n  let val = get(scope, path);\r\n  if (val instanceof Array) {\r\n    el.checked = val.some((v) => v == el.value);\r\n    return;\r\n  }\r\n  el.checked = get(scope, path) == el.value;\r\n};\r\n\r\n/**\r\n * add radio binding handler\r\n */\r\naddBindingHandler((el, path, scope) => {\r\n  if (el.type === \"radio\" && el.nodeName == \"INPUT\") {\r\n    unbind(el, \"change\");\r\n    bind(el, \"change\", () => {\r\n      const value = get(scope, path);\r\n      if (value instanceof Array) {\r\n        value.splice(0, value.length, el.value);\r\n      } else {\r\n        set(scope, path, el.value);\r\n      }\r\n    });\r\n    return updateRadio;\r\n  }\r\n});\r\n\r\nconst updateCheckbox = (el, path, scope) => {\r\n  const tureVal =\r\n    (el.prevProps && el.prevProps[\"o-true-value\"]) ??\r\n    el.getAttribute(\"o-true-value\") ??\r\n    true;\r\n  let value = get(scope, path);\r\n  if (value instanceof Array) {\r\n    el.checked = value.some((v) => v == el.value);\r\n  } else {\r\n    el.checked = value == tureVal;\r\n  }\r\n};\r\n/**\r\n * add checkbox binding handler\r\n */\r\naddBindingHandler((el, path, scope) => {\r\n  if (el.type === \"checkbox\" && el.nodeName == \"INPUT\") {\r\n    const tureVal =\r\n      (el.prevProps && el.prevProps[\"o-true-value\"]) ??\r\n      el.getAttribute(\"o-true-value\") ??\r\n      true;\r\n    const falseVal =\r\n      (el.prevProps && el.prevProps[\"o-false-value\"]) ??\r\n      el.getAttribute(\"o-false-value\") ??\r\n      false;\r\n    unbind(el, \"change\");\r\n    bind(el, \"change\", () => {\r\n      let value = get(scope, path);\r\n      if (value instanceof Array) {\r\n        let valSet = new Set(value);\r\n        if (el.checked) {\r\n          valSet.add(el.value);\r\n        } else {\r\n          valSet.delete(el.value);\r\n        }\r\n        value.splice(0, value.length, ...valSet);\r\n      } else {\r\n        set(scope, path, el.checked ? tureVal : falseVal);\r\n      }\r\n    });\r\n\r\n    return updateCheckbox;\r\n  }\r\n});\r\n//input\r\n\r\nconst updateInput = (el, path, scope) => {\r\n  el.value = get(scope, path) ?? \"\";\r\n  // checkRequired(el)\r\n};\r\n/**\r\n * add input binding handler\r\n */\r\naddBindingHandler((el, path, scope) => {\r\n  if (el.nodeName == \"INPUT\") {\r\n    let pattern = el.getAttribute(\"input-pattern\");\r\n    if (pattern) {\r\n      let reg = new RegExp(pattern);\r\n      unbind(el, \"keypress\");\r\n      //\u8FC7\u6EE4\u8F93\u5165\u5B57\u7B26\r\n      bind(el, \"keypress\", (evt) => {\r\n        if (evt.key.length == 1 && !reg.test(`${el.value}${evt.key}`)) {\r\n          evt.preventDefault();\r\n        }\r\n      });\r\n    }\r\n\r\n    unbind(el, \"input\");\r\n    bind(el, \"input\", (evt) => {\r\n      set(scope, path, el.value);\r\n      // checkRequired(el)\r\n    });\r\n\r\n    return updateInput;\r\n  }\r\n});\r\n\r\n//input\r\n\r\nconst updateComponent = (el, path, scope) => {\r\n  el.value = get(scope, path) ?? null;\r\n  // checkRequired(el)\r\n};\r\n/**\r\n * add customEl binding handler\r\n */\r\naddBindingHandler((el, path, scope) => {\r\n  if (Reflect.has(el, \"value\")) {\r\n    unbind(el, \"change\");\r\n    bind(el, \"change\", () => {\r\n      const value = get(scope, path);\r\n      if (value instanceof Array) {\r\n        value.splice(0, value.length, el.value);\r\n      } else {\r\n        set(scope, path, el.value);\r\n      }\r\n    });\r\n\r\n    return updateComponent;\r\n  }\r\n});\r\n\r\nextend(\"model\", (el, path, scope) => {\r\n  let raw = scope;\r\n  scope = scope.bindingScope ?? scope.props?.bindingScope ?? scope;\r\n  if (scope === false) {\r\n    raw = scope = window;\r\n  }\r\n\r\n  let bindings = raw.__bindings ?? (raw.__bindings = []);\r\n\r\n  //the o-model attr \u987A\u5E8F\u53EF\u4EE5\u6253\u4E71\r\n  Promise.resolve().then(() => {\r\n    for (let handler of BINDING_HANDLERS) {\r\n      let updateFunction = handler(el, path, scope);\r\n      if (typeof updateFunction === \"function\") {\r\n        bindings.push({\r\n          element: el,\r\n          path,\r\n          updateFunction,\r\n        });\r\n        updateFunction(el, path, scope);\r\n        break;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (!raw.hasOwnProperty(\"updateBindings\")) {\r\n    raw.updateBindings = () => {\r\n      for (let binding of bindings) {\r\n        binding.updateFunction(binding.element, binding.path, scope);\r\n      }\r\n    };\r\n  }\r\n});\r\n"],
  "mappings": "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",
  "names": ["HTMLElement"]
}
